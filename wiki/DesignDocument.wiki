#summary Initial design documentation.
#labels Phase-Design,Featured

=Project 'pedigree'=
=An Initial Design Document on Aims and Organisation=

_Revision history:_

_Initial outline – James Molloy 18-Jan-08_

_Update to reflect Discussion – James Pritchett 18-Jan-08_

==Aims of the project==

Project 'pedigree' aims to develop a Modern Operating System, primarily for use on IBM-PC descended x86 computer's of all sectors. The System will need to be compatible with both IA-32 and x64 platforms and have support for multiple processing unit's in numerous configurations. Those configurations including but not limited to, Symmetric Multi-Processing, Asymmetric Multi-Processing, where each Processing core will be capable of supporting features different from the rest, NUMA systems, distributed memory system's and distributed shared memory system's whether tightly coupled by a single physical computer or loosely within a tight cluster.

The project's development will be based on both new and previous designs, and is intended to be a practical implementation of all features and not developed purely as a learning tool or for demonstration. This means that all sectors of general purpose and common specialist system's will be considered in the design in order to provide a solid base for the development of a modern system not plagued by past compatibilities. It will however aim to support existing system's and environment's without intended cost to system performance. As a base for this and for practical purposes, implementation of POSIX support will be a main system goal. The support will include not only software compatibility, but Kernel Interface and a set of POSIX standard applications.

==How the project is organised==

===Logical structure===

The Project 'pedigree' Kernel is intended to run from the moment it is called without having to prepare itself or the system. All necessary Kernel Modules required for it to begin operation will be loaded before it receives control and the expected machine state will be in place. This machine state includes Segment and Paging, as well as any expected device states and known code locations. The Boot loader will therefore have to handle all necessary initialisation of the system before passing control. In order to maintain a unified device interface it will also handle primary legacy device detection on behalf of the kernel and provide the information in a format understandable to the kernel without major modification.

The Kernel proper will contain only those components always necessary to the system and which are not dependent on any external factors (Processor Type, Processor State, Architecture etc.). Any components that are optional or dependent upon other factors are to be separate from and initialized by the kernel. Those Modules which are optional in general but required by an instance of the kernel when it begins will be loaded by the boot loader, then presented in such a way that the kernel initializes them without having to handle them as special cases. It will treat them no different from any other Hot Pluggable module.

(Carry on here about core modules)
===Directory structure===

(what should go in each directory in the source tree)
{{{
|-- build                       -- CD into this directory to build Pedigree.
|-- docs                        -- Documentation
`-- src                         -- All source files
    |-- drivers	                -- Drivers, e.g. Ext2, Ethernet, etc etc
    |-- subsys                  -- User mode subsystems
    |   |-- dos                 -- DOS compatibility subsystem
    |   |-- native              -- Native subsystem – libc etc.
    |   |-- posix               -- POSIX compatibility subsystem
    |   `-- security            -- Implements signing of drivers / modules.
    |-- system                  -- All system (kernel+module) files
    |   |-- boot                -- Bootstrapper
    |   |-- kernel              -- Kernel
    |   |   |-- debugger        -- Kernel debugger
    |   |   |-- devices         -- Consoles etc.
    |   |   |-- fs              -- Virtual filesystem
    |   |   |-- machine         -- “Machine state” including IDT and GDT.
    |   |   |   |-- x86         -- x86 specific ”machine state”.
    |   |   |   |-- x86_64      -- x86-64 specific ”machine state”.
    |   |   |   `-- x86_common  -- ”machine state” common to x86 and x86-64.
    |   |   |-- memory          -- Virtual and physical memory manager.
    |   |   `-- process         -- Process and processor management.
    |   |-- modules             -- Kernel modules, e.g. VFS, network manager.
    |   |   |-- test
    |   |   `-- test2
    |   `-- utilities           -- Shared container classes, Maps, hashtables, linked lists etc.
    `-- user
        |-- applications        -- User space applications. Can be posix or native (or dos)
        `-- libraries           -- User space libraries.
            `-- 8086            -- The 8086 emulation library.
}}}
===Interface between the boot loader and kernel===

All Structures presented to the Kernel by the Boot loader will be in known location, accessible to the kernel when it first gains control. Information passed includes details on each CPU and it's features, NUMA domains, physical memory, legacy devices and Loaded Modules.
===System call interface (s)===

To facilitate both old and new systems, the system call interface shall be decoupled from the implementation of system calls, so that transparently SYSENTER, SYSCALL or a more standard INT 0x80 interface can be used. The kernel will trap all syscalls and attempt to handle them. However, kernel modules shall be able to register their own syscalls with the kernel, along with a callback function. An example of this would be the VFS module, registering syscalls for open(), close(), etc.

===Kernel modules / drivers===

(are there any interface difference between the two? if so, what? and what is the interface for each?)
Scheduler
The short term, or primary scheduler should know nothing about Processes. All it knows about are Threads. Every Process can have multiple, and at least one, Thread.

===The build system===
Every directory that contains source files should have a file called “directory.mk” in. The directory.mk files are written in makefile syntax and detail the files which need to be compiled in this directory. this is done thus:
CXXSRC += $(SRC)/<the directory I am in relevant to the src/ directory>/myfile.cc
There are similar variables, ASMSRC, CSRC and OBJ, in case some precompiled object needs to be linked.
The top level makefile calls down to several others – Makefile.bootstrap, Makefile.kernel and Makefile.modules. The bootstrap makefile makes the bootloader. It contains a DIRECTORIES variable with all directories and subdirectories of src/boot. If you add a new subdirectory, add it to this variable. The same applies for Makefile.kernel. Makefile.modules is called for every module found in src/modules/directory.mk (a variable, MODULES, is created in this file). It is assumed that no module has any subdirectories.

==Style guidelines==

These are not set in stone, but abiding by the same style will ensure consistency.
===Style of C++ / .h source files===
  * Classes should be named in UpperCamelCase. Each class should have at the least its own .h file, and unless it is abstract or for some reason has limited functionality, its own .cc file.
  * All C++ source files should end in either .h or .cc , NOT .cpp.
  * All global functions which are non-trivial should have their own .cc file. The declarations for multiple related global functions can and should be collated in one .h   file.
  * All functions shall be named in lowerCamelCase.
  * All variables shall be named in lowerCamelCase, prefixed by hungarian notation depending on type, for example g_ for a global variable, m_ for a member variable, p for a pointer, and b for a bool, so a member pointer could be called m_pMyPointer.
  * Every declaration should have an associated comment. The comment should be in `/** ... */` form OR `/// ...` form, so that doxygen can process them. The 3-clause BSD license should be applied on the top of every file, see [License].
  * Macros shall be in uppercase, as should any preprocessor flags.
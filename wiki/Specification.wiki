#summary Final specification for each aspect of the system.

=Bootstrapper=



=Kernel-bootstrapper interface=

The final stage of the bootloader will be written in C++, meaning that information can be transferred to the kernel in a class form. The kernel therefore should not have to perform additional processing on any information given it to get it into a useable format.

The bootstrapper will pass a class containing:

  * this
  * this
  * and this.

=Registry=

The 'registry', for want of a better word, is a tree based structure, the leaf nodes of which are arrays key-value pairs. These pairs range from kernel use only (heap algorithm type, scheduler algorithm etc) to application use. Applications, when querying the registry, will only see a leaf node belonging to them (tree structure is not exposed). Programs are digitally signed, and a program with the same digital signature as another is allowed to view and change key-value pairs in that other's leaf node.

=Kernel internals=

The kernel image is made up of three parts: a debugger, machine specific module, and the kernel proper. The first is optional, and the second may be swapped. All of these parts are compiled as shared objects and are linked in place at runtime by the bootstrapper.

==Debugger==

The debugger shall consist of a CLI, command backend, syscall interface, and  (optionally) a GDB stub.

The CLI shall be designed to run in 80x25 text mode on a monitor/keyboard, or via a serial line). The drivers for these devices (serial port, monitor, keyboard) shall be contained in the debugger, so debugging of "real" device drivers is possible.

The command backend shall try to be as frontend agnostic as possible, by taking input and providing output in char`*` form. However, a backend function may also take a DebuggerIO`*` parameter, which will allow it to fully control the output, for example for a scrolling log display or program trace.

_Interface definitions:_

{{{
class DebuggerIO
{
public:

  /**
   * Enumeration of all possible foreground and background colours.
   */
  enum Colour
  {
    Black       =0,
    Blue        =1,
    Green       =2,
    Cyan        =3,
    Red         =4,
    Magenta     =5,
    Orange      =6,
    LightGrey   =7,
    DarkGrey    =8,
    LightBlue   =9,
    LightGreen  =10,
    LightCyan   =11,
    LightRed    =12,
    LightMagenta=13,
    Yellow      =14,
    White       =15,
  };

  /**
   * Default constructor and destructor.
   */
  DebuggerIO() {}
  ~DebuggerIO() {};

  /**
   * Forces the command line interface not to use the specified number of lines
   * from either the top or bottom of the screen, respectively. Can be used to
   * create status lines that aren't destroyed by screen scrolling.
   */
  virtual void setCliUpperLimit(int nlines) {};
  virtual void setCliLowerLimit(int nlines) {};

  /**
   * Enables or disables the command line interface, allowing full access to the display.
   */
  virtual void enableCli() {};
  virtual void disableCli() {};

  /**
   * Writes the given text out to the CLI, in the given colour and background colour.
   */
  virtual void writeCli(const char *str, Colour foreColour, Colour backColour) {};

  /**
   * Reads a command from the interface. Blocks until a character is pressed, and then
   * the current buffer is returned in *str, and the return value is true if the command
   * is complete (if enter has been pressed). *str will never exceed maxLen.
   */
  virtual bool readCli(char *str, int maxLen, DebuggerCommand *pAutoComplete) {};

  /**
   * Draw a line of characters in the given fore and back colours, in the 
   * horizontal or vertical direction. Note that if the CLI is enabled,
   * anything drawn across the CLI area can be wiped without warning.
   */
  virtual void drawHorizontalLine(char c, int row, int colStart, int colEnd, Colour foreColour, Colour backColour) {};
  virtual void drawVerticalLine(char c, int col, int rowStart, int rowEnd, Colour foreColour, Colour backColour) {};

  /**
   * Draws a string of text at the given location in the given colour.
   * note that wrapping is not performed, the string will be clipped.
   */
  virtual void drawString(const char *str, int row, int col, Colour foreColour, Colour backColour) {};

  /**
   * Returns the width and height respectively of the console.
   */
  virtual int getWidth() {};
  virtual int getHeight() {};

  /**
   * Allows disabling of refreshes, for example when deleting something then writing it back.
   */
  virtual void enableRefreshes() {};
  virtual void disableRefreshes() {};
  virtual void forceRefresh() {};
  
  /**
   * Gets a character from the keyboard. Blocking. Returns 0 for a nonprintable character.
   */
  virtual char getChar() {};

};

class DebuggerCommand
{
public:
  DebuggerCommand() {};
  ~DebuggerCommand() {};
  
  /**
   * Return an autocomplete string, given an input string. The string put into *output must not
   * exceed len in length.
   */
  virtual void autocomplete(char *input, char *output, int len) {};

  /**
   * Execute the command with the given screen. The command can take over the screen while
   * executing, but must return it to CLI mode (via enableCLI) before returning.
   * \return True if the debugger should continue accepting commands, false if it should return
   *         control to the kernel.
   */
  virtual bool execute(char *input, char *output, int len, DebuggerIO *screen) {};
  
  /**
   * Returns the string representation of this command.
   */
  virtual const char *getString() {};
};
}}}

==Machine specific interface/module==

==Kernel proper==

===Heap===

===Interchangeable schedulers===

===Memory Map===

The memory map is a means of discovering (i) Which bits of address space are free to map, for example, a shared object, and (ii) Which binary/object file to look in when looking up a symbol name.

We would therefore like some means of distinguishing between several concurrently mapped binaries/objects. String descriptions would be the most versatile and descriptive, but string comparisons are slow.

So, When first mapped, every object will register a string comparison with a word-length (32/64 bit) identifier of their choice. This ID will commonly be a pointer to the ELF32, PE or File object they are mapping, as this is logical, although it is not required.

When mapping more memory, for example during a sbrk call, the same identifier will be used when requesting a mapping from the memory map, so that adjoining chunks from the same source can be coalesced.

_Interface definitions:_

{{{

}}}

=Kernel-module interface=

=Module-driver interface=

=Kernel-app interface=

=App - Subsystem - Kernel interface=

=Subsystems=

=GUI=

==Mode switching==

==Interface==

=Userland apps=
#summary Final specification for each aspect of the system.

=Bootstrapper=



=Kernel-bootstrapper interface=

The final stage of the bootloader will be written in C++, meaning that information can be transferred to the kernel in a class form. The kernel therefore should not have to perform additional processing on any information given it to get it into a useable format.

The bootstrapper will pass a class containing:

  * this
  * this
  * and this.

=Registry=

The 'registry', for want of a better word, is a tree based structure, the leaf nodes of which are arrays key-value pairs. These pairs range from kernel use only (heap algorithm type, scheduler algorithm etc) to application use. Applications, when querying the registry, will only see a leaf node belonging to them (tree structure is not exposed). Programs are digitally signed, and a program with the same digital signature as another is allowed to view and change key-value pairs in that other's leaf node.

=Kernel internals=

The kernel image is made up of three parts: a debugger, machine specific module, and the kernel proper. The first is optional, and the second may be swapped. All of these parts are compiled as shared objects and are linked in place at runtime by the bootstrapper.

==Debugger==

The debugger shall consist of a CLI, command backend, syscall interface, and  (optionally) a GDB stub.

The CLI shall be designed to run in 80x25 text mode on a monitor/keyboard, or via a serial line). The drivers for these devices (serial port, monitor, keyboard) shall be contained in the debugger, so debugging of "real" device drivers is possible.

The command backend shall try to be as frontend agnostic as possible, by taking input and providing output in char`*` form. However, a backend function may also take a DebuggerIO`*` parameter, which will allow it to fully control the output, for example for a scrolling log display or program trace.

==Machine specific interface/module==

==Kernel proper==

===Heap===

===Interchangeable schedulers===

===Memory Map===

The memory map is a means of discovering (i) Which bits of address space are free to map, for example, a shared object, and (ii) Which binary/object file to look in when looking up a symbol name.

We would therefore like some means of distinguishing between several concurrently mapped binaries/objects. String descriptions would be the most versatile and descriptive, but string comparisons are slow.

So, When first mapped, every object will register a string comparison with a word-length (32/64 bit) identifier of their choice. This ID will commonly be a pointer to the ELF32, PE or File object they are mapping, as this is logical, although it is not required.

When mapping more memory, for example during a sbrk call, the same identifier will be used when requesting a mapping from the memory map, so that adjoining chunks from the same source can be coalesced. _NOTE: Please see section 'File Loaders' for a definition of class FileLoader._

===File Loaders===

The virtual FileLoader class is an interface for any class which implements the loading of either executable or shared objects into virtual memory.

=Kernel-module interface=

=Module-driver interface=

=Kernel-app interface=

=App - Subsystem - Kernel interface=

=Subsystems=

=GUI=

==Mode switching==

==Interface==

=Userland apps=
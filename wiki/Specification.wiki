#summary Final specification for each aspect of the system.

=Notes from bluecode=
 * Don't use "unsigned int" for a pointer type (class MemoryMap), I'll provide a typedef for this kind of thing I think...
 * Please use unsigned types if the sign is not needed (string length e.g.)
 * Please use "const type *" if the value pointed to is not changed by the function call

=Bootstrapper=



=Kernel-bootstrapper interface=

The final stage of the bootloader will be written in C++, meaning that information can be transferred to the kernel in a class form. The kernel therefore should not have to perform additional processing on any information given it to get it into a useable format.

The bootstrapper will pass a class containing:

  * this
  * this
  * and this.

=Registry=

The 'registry', for want of a better word, is a tree based structure, the leaf nodes of which are arrays key-value pairs. These pairs range from kernel use only (heap algorithm type, scheduler algorithm etc) to application use. Applications, when querying the registry, will only see a leaf node belonging to them (tree structure is not exposed). Programs are digitally signed, and a program with the same digital signature as another is allowed to view and change key-value pairs in that other's leaf node.

=Kernel internals=

The kernel image is made up of three parts: a debugger, machine specific module, and the kernel proper. The first is optional, and the second may be swapped. All of these parts are compiled as shared objects and are linked in place at runtime by the bootstrapper.

==Debugger==

The debugger shall consist of a CLI, command backend, syscall interface, and  (optionally) a GDB stub.

The CLI shall be designed to run in 80x25 text mode on a monitor/keyboard, or via a serial line). The drivers for these devices (serial port, monitor, keyboard) shall be contained in the debugger, so debugging of "real" device drivers is possible.

The command backend shall try to be as frontend agnostic as possible, by taking input and providing output in char`*` form. However, a backend function may also take a DebuggerIO`*` parameter, which will allow it to fully control the output, for example for a scrolling log display or program trace.

_Interface definitions:_

{{{
class DebuggerIO
{
public:

  /**
   * Enumeration of all possible foreground and background colours.
   */
  enum Colour
  {
    Black       =0,
    Blue        =1,
    Green       =2,
    Cyan        =3,
    Red         =4,
    Magenta     =5,
    Orange      =6,
    LightGrey   =7,
    DarkGrey    =8,
    LightBlue   =9,
    LightGreen  =10,
    LightCyan   =11,
    LightRed    =12,
    LightMagenta=13,
    Yellow      =14,
    White       =15,
  };

  /**
   * Default constructor and destructor.
   */
  DebuggerIO() {}
  ~DebuggerIO() {};

  /**
   * Forces the command line interface not to use the specified number of lines
   * from either the top or bottom of the screen, respectively. Can be used to
   * create status lines that aren't destroyed by screen scrolling.
   */
  virtual void setCliUpperLimit(int nlines) {};
  virtual void setCliLowerLimit(int nlines) {};

  /**
   * Enables or disables the command line interface, allowing full access to the display.
   */
  virtual void enableCli() {};
  virtual void disableCli() {};

  /**
   * Writes the given text out to the CLI, in the given colour and background colour.
   */
  virtual void writeCli(const char *str, Colour foreColour, Colour backColour) {};

  /**
   * Reads a command from the interface. Blocks until a character is pressed, and then
   * the current buffer is returned in *str, and the return value is true if the command
   * is complete (if enter has been pressed). *str will never exceed maxLen.
   */
  virtual bool readCli(char *str, int maxLen, DebuggerCommand *pAutoComplete) {};

  /**
   * Draw a line of characters in the given fore and back colours, in the 
   * horizontal or vertical direction. Note that if the CLI is enabled,
   * anything drawn across the CLI area can be wiped without warning.
   */
  virtual void drawHorizontalLine(char c, int row, int colStart, int colEnd, Colour foreColour, Colour backColour) {};
  virtual void drawVerticalLine(char c, int col, int rowStart, int rowEnd, Colour foreColour, Colour backColour) {};

  /**
   * Draws a string of text at the given location in the given colour.
   * note that wrapping is not performed, the string will be clipped.
   */
  virtual void drawString(const char *str, int row, int col, Colour foreColour, Colour backColour) {};

  /**
   * Returns the width and height respectively of the console.
   */
  virtual int getWidth() {};
  virtual int getHeight() {};

  /**
   * Allows disabling of refreshes, for example when deleting something then writing it back.
   */
  virtual void enableRefreshes() {};
  virtual void disableRefreshes() {};
  virtual void forceRefresh() {};
  
  /**
   * Gets a character from the keyboard. Blocking. Returns 0 for a nonprintable character.
   */
  virtual char getChar() {};

};

class DebuggerCommand
{
public:
  DebuggerCommand() {};
  ~DebuggerCommand() {};
  
  /**
   * Return an autocomplete string, given an input string. The string put into *output must not
   * exceed len in length.
   */
  virtual void autocomplete(char *input, char *output, int len) {};

  /**
   * Execute the command with the given screen. The command can take over the screen while
   * executing, but must return it to CLI mode (via enableCLI) before returning.
   * \return True if the debugger should continue accepting commands, false if it should return
   *         control to the kernel.
   */
  virtual bool execute(char *input, char *output, int len, DebuggerIO *screen) {};
  
  /**
   * Returns the string representation of this command.
   */
  virtual const char *getString() {};
};
}}}

==Machine specific interface/module==

==Kernel proper==

===Heap===

===Interchangeable schedulers===

===Memory Map===

The memory map is a means of discovering (i) Which bits of address space are free to map, for example, a shared object, and (ii) Which binary/object file to look in when looking up a symbol name.

We would therefore like some means of distinguishing between several concurrently mapped binaries/objects. String descriptions would be the most versatile and descriptive, but string comparisons are slow.

So, When first mapped, every object will register a string comparison with a word-length (32/64 bit) identifier of their choice. This ID will commonly be a pointer to the ELF32, PE or File object they are mapping, as this is logical, although it is not required.

When mapping more memory, for example during a sbrk call, the same identifier will be used when requesting a mapping from the memory map, so that adjoining chunks from the same source can be coalesced. _NOTE: Please see section 'File Loaders' for a definition of class FileLoader._

_Interface definitions:_

{{{
class MemoryMap
{
public:
  /**
   * Constructor - doesn't need to do much.
   */
  MemoryMap();
  ~MemoryMap();

  /**
   * Registers an ID with the given description string.
   * \return true on success, false if the ID was taken, or was zero.
   * \note Zero is NOT a valid ID.
   */
  bool registerID(unsigned int nId, const char *pStr, class FileLoader *pSymbolLookup=0);
  
  /**
   * Unregisters an ID with its description string.
   */
  void unregisterID(unsigned int nId);
  
  /**
   * Marks a region of memory as 'mapped'. Takes an associated source ID as
   * given to registerID.
   * \return true on success, false if the region is already mapped.
   */
  bool map(unsigned int nStart, unsigned int nLength, unsigned int nId);
  
  /**
   * Marks a region of memory previously 'mapped' as now 'unmapped'.
   * \return true on success, false if no such region existed.
   */
  bool unmap(unsigned int nStart);
  
  /**
   * Returns the ID of the region the given address is in. Returns zero otherwise.
   */
  unsigned int lookup(unsigned int nAddress);
  
  /**
   * Returns the description string for a given ID.
   */
  const char *getDescription(unsigned int nId);
  
  /**
   * Returns the FileLoader for a given ID.
   */
  class FileLoader *getFileLoader(unsigned int nId);
};
}}}

===File Loaders===

The virtual FileLoader class is an interface for any class which implements the loading of either executable or shared objects into virtual memory.

{{{
class FileLoader
{
public:
  /**
   * Constructor. Doesn't do much.
   */
  virtual FileLoader() {}
  virtual ~FileLoader() {}

  /**
   * This explicit load function allows the use of global concrete objects.
   * \param pFile Pointer to the contents of the file, in accessible memory. The memory it
   *              is in is considered temporary and may be destroyed by the caller when this
   *              function completes.
   * \param nBufferLength Length of the buffer pointed to by pFile.
   */
  virtual bool load(void *pFile, unsigned int nBufferLength) =0;
  
  /**
   * Forces an unmap and cleanup of all mapped regions.
   */
  virtual void unload();
  
  /**
   * Looks up the symbol at location 'nAddress'. Returns NULL if none found.
   * \param[in] nAddress The address to look up.
   * \param[out] pSymbolStart The start location of the retrieved symbol (Optional).
   */
  virtual const char *lookupSymbol(unsigned int nAddress, unsigned int *pSymbolStart);
};
}}}

=Kernel-module interface=

=Module-driver interface=

=Kernel-app interface=

=App - Subsystem - Kernel interface=

=Subsystems=

=GUI=

==Mode switching==

==Interface==

=Userland apps=
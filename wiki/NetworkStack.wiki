#summary This outlines design for the network stack.

= Abstract =

This document outlines the design for the network stack that is to be implemented into Pedigree. All network stack related documentation is to be in this document (though more detailed individual features may be in other wiki pages)


= Details =

Ideas...

A class base for the network stack (something like NetworkStack) handles all the main functionality.

Each individual protocol is handled by an individual class (ie, NetworkTcp, or even just Tcp) which provides functionality via a static instance (Tcp::instance()).

NetworkStack knows about each of these protocols (as does each of the other protocols, so Ip can pass on to Udp and Tcp, as an example).

Sending a packet to the network could be done either via NetworkStack (to provide abstraction) or via the protocol object itself (Tcp::instance().send, for instance).

Receiving goes through the stack, where NetworkStack passes onto Ethernet, then Ethernet onto Arp, Ip, and so on.

What if device drivers call NetworkStack::receive directly when a packet arrives? That stops a requirement for getPacket, as the network stack receives the packet straight from the device driver. It also makes it more event-based and means no polling for packets.

** Latest Ideas **

Things like UDP and TCP have a concept of ports, which are for purposes of the following ideas just like linear queues.

UDP will be used for all description, however the concept applies to TCP (to an extent).

If we consider a port to be an "Endpoint", then each incoming packet needs to go to an Endpoint. This Endpoint may not be a valid port, that's not a problem - the packet can be discarded in a "catchall" Endpoint.

Each Endpoint has a port and a packet queue. It also has access to the UDP protocol layer in order to send packets via UDP. Incoming packets can be read by applications (or socket layers) by interfacing directly with the Endpoint. All protocols that require Endpoints (for now, UDP and TCP) also provide a "Manager" object (UdpManager, TcpManager) which keeps track of all Endpoints.

A typical UDP server application might do the following:
  * Query UdpManager for an Endpoint on port 1337. UdpManager finds this port is unusued, creates a new Endpoint, and returns it.
  * Enter into a main loop of some sort. This sort of loop most likely just spins on Endpoint::receive, or perhaps Endpoint::dataReady - both of which will probably be blocking calls (a single parameter to dataReady might state whether to block or not).
  * Each iteration of this loop will involve reading the packet data (in the case of Endpoint::dataReady) and then performing an action on it. For purposes of this example, the payload is a request for data.
  * The server places the data into a packet, and sends it back via Endpoint::send.
  * This loop continues until the server ends, where it returns the Endpoint to UdpManager.

In further consideration this could easily be applied to ICMP (IcmpManager).

Basically, to use Udp again as an example, Udp is the *protocol* which provides protocol-level functionality - basically sending and receiving packets. UdpManager controls the upper layer of the protocol - redirecting packets to Endpoints. And finally, UdpEndpoint is the application interface to the UDP protocol.
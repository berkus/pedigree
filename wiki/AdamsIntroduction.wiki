#summary Adam's introduction to Pedigree.

I've tried to create a set of tasks that (a) need doing and (b) will help you see most of the codebase in a progressive manner. Any questions, just give me a shout.

The tasks go from ridonkulously easy to fairly challenging - let me know if you think I'm being patronising! :(

== 1. Add a "read only" flag to filesystems ==

At the moment, a filesystem cannot be mounted read only. This poses a problem, as we currently don't have write capability (left till later so we don't cripple our HDDs accidentally ;) ). I'd like a function in Filesystem that will set the "read-only-ness", and if a write() occurs on a readonly FS, a syscall error should be generated.

Areas to look at:
  * `src/system/modules/vfs` contains the entire virtual filesystem. It's small, as we use a "windows-style" FS with drives instead of mountpoints. This simplifies things and allows us to pawn off some checking etc to the filesystem implementations instead of the VFS.
  * `src/system/modules/vfs/Filesystem.cc` is where the magic happens. A File object will call the Filesystem its implementation inherits from to pass a read/write/bleh call down the FS stack. the write() function here is your chokepoint where you can stop all writes if needs be.
  * `src/system/include/syscallError.h` defines the macro you'll need to use. It merely sets errno, it doesn't change control flow (so a return; is needed too).
  * `src/system/include/errors.h` defines the error numbers you can pass to SYSCALL_ERROR.

== 2. Page fault handler ==

Currently when a page fault occurs, if the debugger is enabled it is jumped to, else the system panics.

We need a dedicated handler that can decide what to do. We'll need this to implement copy-on-write and mmapping, so it needs to be there.

For the moment, the best plan would be to check if there's a thread running (i.e. panic if we're in the early stages of boot), print a descriptive error to the kernel log and kill the task outright. We can deal with SIGSEGV etc at a later date when we've actually implemented signals.

Areas to look at:
  * `src/system/include/processor/InterruptManager.h` contains the abstract header for an InterruptManager.
  * `src/system/include/processor/InterruptHandler.h` contains the abstract InterruptHandler class, that any interrupt handler must derive.
  * `src/system/kernel/core/processor/x86` is the directory that contains all the processor-specific code for the IA32 architecture. This is where the header and implementation of your solution should go.
  * `src/system/kernel/core/processor/x86/InterruptManager.cc` is the actual manager implementation.
  * `src/system/include/process/Process.h` the Process class, including a cunningly named "void kill();" member.
  * `src/system/include/Log.h` defines the macros for adding stuff to the kernel log.

== 3. Debug frame information for modules ==

We have two methods for call backtracing - the "normal" EBP chain, and the default, which is to use DWARF-2.

DWARF is the debugging standard. We use a particular part of the DWARF info, the debug_table section, to help us backtrace. It allows us to backtrace when -fomit-framepointer is enabled, and also on *any* platform. It's platform independent. So we have one backtracer for x86, x86_64, powerpc, mips, and arm (!)

The problem is that we currently don't load in DWARF information for loaded modules. More correctly, the information is loaded into memory, but the backtracer is never informed of it.

It would be nice if the debug tables were retrievable - that is, KernelElf (a specicialised Elf class that can load modules and is generally for the Kernel Elf as opposed to module/program Elfs) already maintains a list of all loaded modules. It should be fairly easy to expose this list so that the backtracer can cycle through them.

Areas to look at:
  * `src/system/include/linker/Elf32.h`, `KernelElf.h` - headers for Elf32 and KernelElf. There is currently a large refactoring operation going on involving the ELF loaders; Elf64 and Elf32 are to be rolled into one class. I'm doing this, albeit slowly, so watch out for code changes. The API should stay the same.
  * `src/system/kernel/linker/Elf32.cc`, `KernelElf.cc` - implementation files for the above.
  * `src/system/kernel/debugger/Backtrace.h`, `Backtrace.cc` - the backtracer.
  * `src/system/kernel/debugger/DwarfUnwinder.h` The DWARF unwinder class.

Things to note:
  * *Dynamic memory can not be used in the debugger.* If the heap is corrupted, we want to know why. We don't want to use it or we'll page fault again! Dynamic memory *can* be used in KernelElf and Elf, but ensure it is not used in the constructor or any function that could be called from the debugger. (Remember the constructor is called before dynamic memory is enabled).
  * Utility classes (in `src/system/include/utilities`) all use dynamic memory. That's List, RangeList, Tree, Cache, etc. Watch out ;)

== 4. Syscall time tracer ==

I like this one. It sounds fun :-)

Some of our syscalls are *dog slow*. I know why they are, mostly. (Mainly it's due to lack of disk cache which kills pretty much everything). I would like to know, however, what's slowing us down. Optimising feels much better when you have shiny numbers to compare and can make a spreadsheet with pretty colours! ;)

What I'd like is a system that would be enabled by a compile flag (off by default). Every function should be able to have a call at its start to trace the time of execution / number of times called etc, something similar to:

{{{
void mySyscallFunction(int foo)
{
  TRACE();

  ... codez ...
}
}}}

Ideally the results should be able to be shown after each TRACE has completed in the log (if enabled, again a compile flag would be ideal), and also in the debugger, so that means implementing a DebuggerCommand.

Areas to look at:
  * `src/system/kernel/debugger` - Contains all the debugger stuff, your tracing code should probably go here too (.h and .cc).
  * `src/system/kernel/debugger/DebuggerCommand.h` - What a debugger command must derive from.
  * `src/system/kernel/debugger/commands` - Where all the debugger commands live. Look in here for examples. Your debugger command should live here (try and seperate the tracing code (in /kernel/debugger) and the command/UI code (in /kernel/debugger/commands)
  * `src/system/include/machine/Timer.h` - A timer class.
  * `src/system/include/machine/Machine.h` - The machine class. You can get at a Timer from here. See the Kernel Log (`src/system/kernel/Log.cc`) for an example of its use.

Ideas from my tiny brain:
  * If TRACE is a macro, you can use __FILE__, __LINE__, __FUNC__(?) etc to make nice information without having to explicitly write it in the function
  * If TRACE expanded out to an object, for example:
{{{
#define TRACE MyTracerObject __tracerObject__;
}}}
then you could use the destructor of the object to terminate the trace when the object goes out of scope (i.e. function finishes) automatically.


That last one sounds like fun actually :P

Have fun! Feel free to ask me anything!

James
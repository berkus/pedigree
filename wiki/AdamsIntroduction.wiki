#summary Adam's introduction to Pedigree.

I've tried to create a set of tasks that (a) need doing and (b) will help you see most of the codebase in a progressive manner. Any questions, just give me a shout.

The tasks go from ridonkulously easy to fairly challenging - let me know if you think I'm being patronising! :(

== 1. Add a "read only" flag to filesystems ==

At the moment, a filesystem cannot be mounted read only. This poses a problem, as we currently don't have write capability (left till later so we don't cripple our HDDs accidentally ;) ). I'd like a function in Filesystem that will set the "read-only-ness", and if a write() occurs on a readonly FS, a syscall error should be generated.

Areas to look at:
  * `src/system/modules/vfs` contains the entire virtual filesystem. It's small, as we use a "windows-style" FS with drives instead of mountpoints. This simplifies things and allows us to pawn off some checking etc to the filesystem implementations instead of the VFS.
  * `src/system/modules/vfs/Filesystem.cc` is where the magic happens. A File object will call the Filesystem its implementation inherits from to pass a read/write/bleh call down the FS stack. the write() function here is your chokepoint where you can stop all writes if needs be.
  * `src/system/include/syscallError.h` defines the macro you'll need to use. It merely sets errno, it doesn't change control flow (so a return; is needed too).
  * `src/system/include/errors.h` defines the error numbers you can pass to SYSCALL_ERROR.

== 2. Page fault handler ==

Currently when a page fault occurs, if the debugger is enabled it is jumped to, else the system panics.

We need a dedicated handler that can decide what to do. We'll need this to implement copy-on-write and mmapping, so it needs to be there.

For the moment, the best plan would be to check if there's a thread running (i.e. panic if we're in the early stages of boot), print a descriptive error to the kernel log and kill the task outright. We can deal with SIGSEGV etc at a later date when we've actually implemented signals.

Areas to look at:
  * `src/system/include/processor/InterruptManager.h` contains the abstract header for an InterruptManager.
  * `src/system/include/processor/InterruptHandler.h` contains the abstract InterruptHandler class, that any interrupt handler must derive.
  * `src/system/kernel/core/processor/x86` is the directory that contains all the processor-specific code for the IA32 architecture. This is where the header and implementation of your solution should go.
  * `src/system/kernel/core/processor/x86/InterruptManager.cc` is the actual manager implementation.
  * `src/system/include/process/Process.h` the Process class, including a cunningly named "void kill();" member.
  * `src/system/include/Log.h` defines the macros for adding stuff to the kernel log.

== 3. Debug frame information for modules ==

We have two methods for call backtracing - the "normal" EBP chain, and the default, which is to use DWARF-2.

DWARF is the debugging standard. We use a particular part of the DWARF info, the debug_table section, to help us backtrace. It allows us to backtrace when -fomit-framepointer is enabled, and also on *any* platform. It's platform independent. So we have one backtracer for x86, x86_64, powerpc, mips, and arm (!)

The problem is that we currently don't load in DWARF information for loaded modules. More correctly, the information is loaded into memory, but the backtracer is never informed of it.

It would be nice if the debug tables were retrievable - that is, KernelElf (a specicialised Elf class that can load modules and is generally for the Kernel Elf as opposed to module/program Elfs) already maintains a list of all loaded modules. It should be fairly easy to expose this list so that the backtracer can cycle through them.

Areas to look at:
  * `src/system/include/linker/Elf32.h`, `KernelElf.h` - headers for Elf32 and KernelElf. There is currently a large refactoring operation going on involving the ELF loaders; Elf64 and Elf32 are to be rolled into one class. I'm doing this, albeit slowly, so watch out for code changes. The API should stay the same.
  * `src/system/kernel/linker/Elf32.cc`, `KernelElf.cc` - implementation files for the above.
  * `src/system/kernel/debugger/Backtrace.h`, `Backtrace.cc` - the backtracer.
  * `src/system/kernel/debugger/DwarfUnwinder.h` The DWARF unwinder class.

Things to note:
  * *Dynamic memory can not be used in the debugger.* If the heap is corrupted, we want to know why. We don't want to use it or we'll page fault again! Dynamic memory *can* be used in KernelElf and Elf, but ensure it is not used in the constructor or any function that could be called from the debugger. (Remember the constructor is called before dynamic memory is enabled).
  * Utility classes (in `src/system/include/utilities`) all use dynamic memory. That's List, RangeList, Tree, Cache, etc. Watch out ;)

== 4. Syscall time tracer ==

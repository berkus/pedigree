#summary Outlines the interface for I/O in network cards

== Required Reading ==

See DriverInterface for information about the driver I/O interface.

== Interface Definition ==

Network device drivers should implement:
  * read: reads packets into a buffer, the count parameter states how many packets to read in, does not block
  * readBlocking: same as read, except blocks
  * write: writes packets from a buffer to the device, again, the count parameter states how many packets to write, does not block
  * writeBlocking: same as write, blocks
  * ioctl: should provide an interface to change at least the local IP and preferably the subnet and gateway addresses, also should permit modifying device modes (ie, promiscuous mode)
  * driverInit: probes for the device (either on the PCI bus or on ISA) and sets up local structures
  * driverDeInit: cleans up local structures and (optionally) resets the device

== Potential Problems & Questions ==

  * How are IPs and whatnot allocated, and how does the system use it? Are they really going to be in the 
  * Network devices (in my opinion) don't need to know about their IP, they just need to send and receive packets (not even necessary to understand WHAT they're sending)
  * What are these devices installed as in the VFS - "/dev/eth0" et al, or something else?)
  * Probably the most important thing to figure out is how the network _stack_ interfaces with network _devices_ to provide service - especially when there's more than one card.

Answers to points 2 and 3 - devices are not present in the VFS. The stack interfaces with the device by accessing it through the device tree - There's a Network (: public Device) class in there at the moment that isn't defined as yet - that would contain all network device functions (no ioctls, the actual function names), and the stack would interface through that. All modules/drivers have access to the device tree. --JamesM